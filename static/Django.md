# Creating a Website With Django
## New Project and Project Application
First, create the Django project by running the following:
```
% django-admin startproject <project_name>
```
Next, cd into the newly created `project_name` directory, and create an application by running:
```
% py manage.py startapp <app>
```
Finally, add the app to the project by adding `app` to the `INSTALLED_APPS` array in `<project_name>/settings.py`.
## Setting Up URLs
The project's `urls.py` file should import `include` from the `django.urls` module and the `urlspatterns` array should contain:
```
path('<app>/', include('<app>.urls'))
```
Note the forward slash `/` following `<app>` is critically important as it allows URL paths to be constructed by combining `<app>/` with paths from `<app>.urls`.

Next create `<app>/urls.py` and set it up like so:
```
from django.urls import path
from . import views

urlpatterns = [
    
]
```
### Captured Values (Parameters)
The `route` argument passed to `path()` may contain angle brackets (eg. `<username>`) to caputre part of the URL and send it as a keyword arugement to the view it is associated with.
## [Models And Fields](https://docs.djangoproject.com/en/4.1/ref/models/)
A model is to Django what a table is to database. In Python each model is a class that subclasses the Django model class (`django.db.models.Model`). Each model in a Django application is a table in application's database.

Model attributes are known as fields and specify a table's columns and column properties. There are different [Django field types](https://docs.djangoproject.com/en/4.1/ref/models/fields/#field-types) which correspond with SQL data types. For example, below shows the Python Django model and SQL equivalent code for creating a database table:
```
# Python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

-- SQL
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```
Fields take arguments known as field options like `null=False`, `default='Foo'`, and `unique=True` which are equivalent in SQL to `NOT NULL`, `DEFAULT 'Foo'`, and `UNIQUE`, respectively.

### `models.ForeignKey()`
A field given a field type of `ForeignKey()` will add a column in the local model which references the primary key of a remote model.

### [`models.ManyToManyField()`](https://docs.djangoproject.com/en/4.1/ref/models/fields/#manytomanyfield)
A field given a field type of `ManyToManyField()` will create an intermediary model (join table) that holds two foreign key fields referencing the two sides of the relation. It doesn’t matter which model has the ManyToManyField, but it should only be in one of the models – not both. For example, the Python classes below would allow for the creation of the following table:
```
# Python
class Flight(models.Model):
    id = models.BigAutoField(primary_key=True)


class Passenger(models.Model):
    flight = models.ManyToManyField(
        Flight, blank=True, related_name='passengers')

-- SQL result set after creating flights and passengers
┌────┬──────────────┬───────────┐
│ id │ passenger_id │ flight_id │
├────┼──────────────┼───────────┤
│ 1  │ 1            │ 4         │
│ 2  │ 2            │ 1         │
│ 3  │ 2            │ 3         │
│ 4  │ 3            │ 3         │
└────┴──────────────┴───────────┘
```

### Django Admin Site
After running `% django-admin createsuperuser` and setting up an admin account, the path `<domain>/admin` can be visited, and a page for quickly inserting and deleting records from models can be accessed.
## Views
A view is analagous to the UI view (presentation) a viewer is presented with when they visit a particular part of the application. Views are functions that take a `request` and optionally captured values sent as arguments from the URLconf. Those captured values can then be sent to a particular HTML templates using the `render()` function by passing it a context dictionary. The items in the context dicationary will then be accessible by the tempalte. If a model from app's `models` module is imported then the context dictionary can include the objects assocationed witht that model. Example:
```
from .models import Flight

def index(request):
    return render(request, 'index.html', {
        'flights': Flight.objects.all()
    })
```
### Forms
Forms should be validated on the front-end using HTML addtributes like `required`; however, Django also offers back-end validation methods. A form is a class that inherits Django's `Form` class. The class will have attributes (see [form fields](https://docs.djangoproject.com/en/4.1/ref/forms/fields/)) which will map to HTML `<input>` elements. Arguments such as `max_length` can provided to the form's attributes to enable frontend validation. Backend validation is acheived by calling `is_valid()` on a bound form (a form instantiated with `request.POST` as its argument). Validated data can be accessed via the form's `cleaned_data` attribute. To use the HTML form, an instance of the form should be sent to a template in the context dicitonary, and then it can be called in the template. Note the form include a `<label>` and `<input>` elements but neither `<form>` nor `<input type="submit">` elements.
#### The following shows how all pieces of a Django form are used.
##### Class
```
class AddPassengerToFlightForm(forms.Form):
    passenger = forms.ModelChoiceField(queryset=None)

    def __init__(self, *args, **kwargs):
        flight_id = kwargs.pop('flight_id', None)
        super().__init__(*args, **kwargs)
        if flight_id:
            self.fields['passenger'].queryset = Passenger.objects.exclude(
                flights=flight_id).all()
        else:
            self.fields['passenger'].queryset = Passenger.objects.all()
```
##### Views
```
from django import forms
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render, get_object_or_404
from django.urls import reverse


def flight(request, flight_id):
    # ...
    return render(request, 'flight.html', {
        'form': AddPassengerToFlightForm(flight_id=flight_id)
    })


def add(request, flight_id):
    if request.method == 'POST':
        form = AddPassengerToFlightForm(request.POST) 
        if form.is_valid():
            passenger = form.cleaned_data['passenger']
            flight = get_object_or_404(Flight, pk=flight_id)
            passenger.flights.add(flight)
        else:
            raise Http404

    return HttpResponseRedirect(reverse('flight', args=(flight_id,)))
```
##### URLs
```
from django.urls import path
from . import views

urlpatterns = [
    # ...
    path('<int:flight_id>/add', views.add, name='add')
]
```
##### Template
```
<!-- ... -->

<form action="{% url 'add' flight.id %}" method="POST">{% csrf_token %}
    <header>
        <h2>Add a passenger</h2>
    </header>
    {{ form }}
    <input type="submit" value="Add">
</form>

<!-- ... -->
```
## Templates
Templates make up the final part of Django as a Model-Template-View (MTV) framework and are simply HTML files. As a feature Django templating language called the [Django Template Language](https://docs.djangoproject.com/en/4.1/topics/templates/) which is capable of conditions, loops, and extending other templates. The context dictionary from the particular view which renders the template allows the template to access the properties within the context dictionary. Special templates, such as `404.html`, [can be loaded without providing them to a view](https://docs.djangoproject.com/en/4.1/ref/views/).
